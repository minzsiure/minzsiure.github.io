<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PredClick</title>
    <link rel="stylesheet" href="./css/style.css" />
</head>

<body>
    <div class="wrap">
        <div class="card">
            <h1>PredClick</h1>
            <p>Listen to binaural clicks (left stream in left ear, right stream in right ear). Decide which side had
                more clicks.</p>

            <div class="row">
                <button id="startBtn" class="primary">Start</button>
                <button id="leftBtn" disabled>Left</button>
                <button id="rightBtn" disabled>Right</button>
                <button id="nextBtn" disabled>Next trial</button>
                <button id="sanityBtn">Sanity check</button>
            </div>

            <div class="status" id="status">Press Start.</div>
            <p class="small">Tip: use headphones. (Audio requires a button press.)</p>

            <div class="plotWrap">
                <canvas id="cv" width="920" height="520"></canvas>
                <div id="revealOverlay" class="overlay">
                    <button id="revealBtn" disabled>Reveal</button>
                </div>
            </div>
        </div>
    </div>
    <!-- <script type="module" src="./js/main.js"></script> -->
    <script type="module">
        import { CFG } from "./js/config.js";
        import { rng, poissonKnuth } from "./js/rng.js";
        import { greenBounds, grayIntervalsAt, allowed } from "./js/bounds.js";

        // optional for debugging only:
        window.CFG = CFG;
        window.rng = rng;
        window.greenBounds = greenBounds;
        window.grayIntervalsAt = grayIntervalsAt;
        window.allowed = allowed;

        /** ---------------------------
         *  Evidence trajectory on a grid
         *  --------------------------- */
        function evidenceTrajectory(tL, tR, T, dt) {
            const n = Math.floor(T / dt) + 1;
            const ts = new Float32Array(n);
            const E = new Int32Array(n);
            let iL = 0, iR = 0, e = 0;
            for (let k = 0; k < n; k++) {
                const t = k * dt;
                ts[k] = t;
                while (iL < tL.length && tL[iL] <= t + 1e-12) { e -= 1; iL++; }
                while (iR < tR.length && tR[iR] <= t + 1e-12) { e += 1; iR++; }
                E[k] = e;
            }
            return { ts, E };
        }

        function checkConstraintsOnGrid(traj) {
            const { ts, E } = traj;
            for (let k = 0; k < ts.length; k++) if (!allowed(E[k], ts[k])) return false;
            return true;
        }

        /** ---------------------------
         *  Whole-trial rejection sampler
         *  --------------------------- */
        function generateClicksWithConstraintsBinwise(T, lamPair, dt, maxTriesPerBin) {
            const [lamA, lamB] = lamPair;

            // randomly assign per trial (same as Python)
            let lamL, lamR;
            if (rng() < 0.5) { lamL = lamA; lamR = lamB; }
            else { lamL = lamB; lamR = lamA; }

            const nBins = Math.ceil(T / dt);
            const tL_all = [];
            const tR_all = [];
            let e = 0;

            for (let k = 0; k < nBins; k++) {
                const t0 = k * dt;
                const t1 = Math.min(T, (k + 1) * dt);
                const dtk = t1 - t0;

                let accepted = false;

                for (let tr = 0; tr < maxTriesPerBin; tr++) {
                    const nL = poissonKnuth(lamL * dtk);
                    const nR = poissonKnuth(lamR * dtk);

                    const tL = new Array(nL);
                    const tR = new Array(nR);
                    for (let i = 0; i < nL; i++) tL[i] = t0 + rng() * dtk;
                    for (let i = 0; i < nR; i++) tR[i] = t0 + rng() * dtk;

                    // events = [(tR,+1), (tL,-1)], sorted by time (same as Python)
                    const events = [];
                    for (let i = 0; i < nR; i++) events.push([tR[i], +1, "R"]);
                    for (let i = 0; i < nL; i++) events.push([tL[i], -1, "L"]);
                    events.sort((a, b) => a[0] - b[0]);

                    let e_tmp = e;
                    let ok = true;

                    for (const [tt, de] of events) {
                        e_tmp += de; // IMPORTANT: update first, then check (matches Python)
                        if (!allowed(e_tmp, tt)) { ok = false; break; }
                    }

                    if (ok && allowed(e_tmp, t1)) {
                        // accept bin
                        for (let i = 0; i < nL; i++) tL_all.push(tL[i]);
                        for (let i = 0; i < nR; i++) tR_all.push(tR[i]);
                        e = e_tmp;
                        accepted = true;
                        break;
                    }
                }

                if (!accepted) {
                    throw new Error(`Could not sample an allowed bin at t∈[${t0.toFixed(3)},${t1.toFixed(3)}]`);
                }
            }

            tL_all.sort((a, b) => a - b);
            tR_all.sort((a, b) => a - b);
            return { tL: tL_all, tR: tR_all, lamL, lamR, finalE: (tR_all.length - tL_all.length) };
        }

        function sampleTrial() {
            const T = CFG.T;

            for (let attempt = 0; attempt < CFG.maxAttempts; attempt++) {
                let out;
                try {
                    out = generateClicksWithConstraintsBinwise(
                        T,
                        CFG.lamPair,
                        CFG.dtCheck,                 // use same dt for constraints as Python
                        200                          // max_tries_per_bin (match Python default)
                    );
                } catch (e) {
                    continue; // restart whole trial if any bin fails
                }

                if (CFG.avoidTie && out.finalE === 0) continue;

                const trajPlot = evidenceTrajectory(out.tL, out.tR, T, CFG.dtPlot);
                return { ...out, traj: trajPlot };
            }

            throw new Error("Could not sample a valid trial (constraints too tight).");
        }


        /** ---------------------------
         *  Canvas plotting
         *  --------------------------- */
        const cv = document.getElementById("cv");
        const ctx2d = cv.getContext("2d");

        function clearCanvas() {
            ctx2d.clearRect(0, 0, cv.width, cv.height);
            ctx2d.fillStyle = "rgba(0,0,0,0.10)";
            ctx2d.fillRect(0, 0, cv.width, cv.height);
        }

        function computeYRange(trial) {
            const ts = trial.traj.ts;
            let ymin = +Infinity, ymax = -Infinity;
            for (let k = 0; k < ts.length; k++) {
                const [lo, hi] = greenBounds(ts[k]);
                ymin = Math.min(ymin, lo);
                ymax = Math.max(ymax, hi);
            }
            for (let k = 0; k < trial.traj.E.length; k++) {
                ymin = Math.min(ymin, trial.traj.E[k]);
                ymax = Math.max(ymax, trial.traj.E[k]);
            }
            ymin = Math.floor(ymin) - 2;
            ymax = Math.ceil(ymax) + 2;
            return [ymin, ymax];
        }

        function plotStateSpaceBase(trial) {
            clearCanvas();
            const W = cv.width, H = cv.height;
            const padL = 60, padR = 20, padT = 20, padB = 45;
            const innerW = W - padL - padR;
            const innerH = H - padT - padB;

            const [ymin, ymax] = computeYRange(trial);
            const xOfT = t => padL + (t / CFG.T) * innerW;
            const yOfE = e => padT + (1 - (e - ymin) / (ymax - ymin)) * innerH;

            // green outside shading
            ctx2d.save();
            ctx2d.globalAlpha = 0.18;
            ctx2d.fillStyle = "#aab3bf";
            const step = CFG.dtPlot;
            for (let i = 0; i < Math.floor(CFG.T / step); i++) {
                const tL = i * step, tR = (i + 1) * step, tM = 0.5 * (tL + tR);
                const [glo, ghi] = greenBounds(tM);
                const x0 = xOfT(tL), x1 = xOfT(tR);
                // above hi
                ctx2d.fillRect(x0, yOfE(ghi), (x1 - x0), yOfE(ymin) - yOfE(ghi));
                // below lo
                ctx2d.fillRect(x0, yOfE(ymax), (x1 - x0), yOfE(glo) - yOfE(ymax));
            }
            ctx2d.restore();

            // gray forbidden regions
            ctx2d.save();
            ctx2d.globalAlpha = 0.28;
            ctx2d.fillStyle = "#6b7280";
            for (let i = 0; i < Math.floor(CFG.T / step); i++) {
                const tL = i * step, tR = (i + 1) * step, tM = 0.5 * (tL + tR);
                const ivs = grayIntervalsAt(tM);
                if (!ivs) continue;
                const x0 = xOfT(tL), x1 = xOfT(tR);
                for (const [lo, hi] of ivs) {
                    const y0 = yOfE(hi), y1 = yOfE(lo);
                    ctx2d.fillRect(x0, y0, (x1 - x0), (y1 - y0));
                }
            }
            ctx2d.restore();

            // green bound lines
            ctx2d.save();
            ctx2d.globalAlpha = 0.35;
            ctx2d.strokeStyle = "#cbd5e1";
            ctx2d.lineWidth = 2;
            ctx2d.beginPath();
            for (let i = 0; i <= Math.floor(CFG.T / CFG.dtPlot); i++) {
                const t = i * CFG.dtPlot;
                const [glo] = greenBounds(t);
                const x = xOfT(t), y = yOfE(glo);
                if (i === 0) ctx2d.moveTo(x, y); else ctx2d.lineTo(x, y);
            }
            ctx2d.stroke();

            ctx2d.beginPath();
            for (let i = 0; i <= Math.floor(CFG.T / CFG.dtPlot); i++) {
                const t = i * CFG.dtPlot;
                const [, ghi] = greenBounds(t);
                const x = xOfT(t), y = yOfE(ghi);
                if (i === 0) ctx2d.moveTo(x, y); else ctx2d.lineTo(x, y);
            }
            ctx2d.stroke();
            ctx2d.restore();

            // axes
            ctx2d.save();
            ctx2d.strokeStyle = "rgba(255,255,255,0.35)";
            ctx2d.lineWidth = 1;
            ctx2d.beginPath();
            ctx2d.moveTo(padL, padT);
            ctx2d.lineTo(padL, padT + innerH);
            ctx2d.lineTo(padL + innerW, padT + innerH);
            ctx2d.stroke();
            ctx2d.restore();

            // y ticks: 1 tick per unit, label 0 and every k
            const kLabel = 5;
            ctx2d.save();
            ctx2d.font = "12px ui-sans-serif, system-ui";
            ctx2d.fillStyle = "rgba(255,255,255,0.75)";
            ctx2d.strokeStyle = "rgba(255,255,255,0.18)";
            for (let e = Math.ceil(ymin); e <= Math.floor(ymax); e++) {
                const y = yOfE(e);
                ctx2d.beginPath();
                ctx2d.moveTo(padL - 4, y);
                ctx2d.lineTo(padL, y);
                ctx2d.stroke();
                if (e % kLabel === 0) ctx2d.fillText(String(e), 12, y + 4);
            }
            ctx2d.restore();

            // labels
            ctx2d.save();
            ctx2d.fillStyle = "rgba(255,255,255,0.75)";
            ctx2d.font = "13px ui-sans-serif, system-ui";
            ctx2d.fillText("time (s)", padL + innerW / 2 - 26, H - 14);
            ctx2d.translate(16, padT + innerH / 2 + 40);
            ctx2d.rotate(-Math.PI / 2);
            ctx2d.fillText("evidence (#R - #L)", 0, 0);
            ctx2d.restore();

            // dashed zero line
            ctx2d.save();
            ctx2d.setLineDash([6, 6]);
            ctx2d.strokeStyle = "rgba(255,255,255,0.25)";
            ctx2d.lineWidth = 1;
            ctx2d.beginPath();
            ctx2d.moveTo(padL, yOfE(0));
            ctx2d.lineTo(padL + innerW, yOfE(0));
            ctx2d.stroke();
            ctx2d.restore();

            return { xOfT, yOfE };
        }

        function drawTrajectory(trial, frac) {
            // frac in [0,1] draws up to that fraction of time
            const base = plotStateSpaceBase(trial);
            const { xOfT, yOfE } = base;

            const ts = trial.traj.ts;
            const E = trial.traj.E;
            const tMax = CFG.T * frac;

            const color = (trial.finalE > 0) ? "#ef4444" : (trial.finalE < 0) ? "#3b82f6" : "#22c55e";

            ctx2d.save();
            ctx2d.strokeStyle = color;
            ctx2d.globalAlpha = 0.92;
            ctx2d.lineWidth = 3;
            ctx2d.beginPath();

            let started = false;
            for (let k = 0; k < ts.length; k++) {
                const t = ts[k];
                if (t > tMax) break;
                const x = xOfT(t);
                const y = yOfE(E[k]);
                if (!started) { ctx2d.moveTo(x, y); started = true; }
                else ctx2d.lineTo(x, y);
            }
            ctx2d.stroke();
            ctx2d.restore();
        }

        function computeYRangeFromBoundsOnly() {
            // mimic your Python plot_state_space y-limits:
            // start from green bounds; then expand to include gray intervals; then pad
            const ts = [];
            for (let t = 0; t <= CFG.T + 1e-12; t += CFG.dtPlot) ts.push(t);

            let ymin = +Infinity, ymax = -Infinity;

            // green bounds
            for (const t of ts) {
                const [lo, hi] = greenBounds(t);
                ymin = Math.min(ymin, lo);
                ymax = Math.max(ymax, hi);
            }

            // include gray intervals too (like python does)
            for (const t of ts) {
                const ivs = grayIntervalsAt(t);
                if (!ivs) continue;
                for (const [lo, hi] of ivs) {
                    ymin = Math.min(ymin, lo);
                    ymax = Math.max(ymax, hi);
                }
            }

            ymin = Math.floor(ymin) - 2;
            ymax = Math.ceil(ymax) + 2;
            return [ymin, ymax];
        }

        function plotStateSpaceBaseFixedYRange() {
            clearCanvas();
            const W = cv.width, H = cv.height;
            const padL = 60, padR = 20, padT = 20, padB = 45;
            const innerW = W - padL - padR;
            const innerH = H - padT - padB;

            const [ymin, ymax] = computeYRangeFromBoundsOnly();
            const xOfT = t => padL + (t / CFG.T) * innerW;
            const yOfE = e => padT + (1 - (e - ymin) / (ymax - ymin)) * innerH;

            // green outside shading
            ctx2d.save();
            ctx2d.globalAlpha = 0.18;
            ctx2d.fillStyle = "#aab3bf";
            const step = CFG.dtPlot;
            for (let i = 0; i < Math.floor(CFG.T / step); i++) {
                const tL = i * step, tR = (i + 1) * step, tM = 0.5 * (tL + tR);
                const [glo, ghi] = greenBounds(tM);
                const x0 = xOfT(tL), x1 = xOfT(tR);
                // above hi
                ctx2d.fillRect(x0, yOfE(ghi), (x1 - x0), yOfE(ymin) - yOfE(ghi));
                // below lo
                ctx2d.fillRect(x0, yOfE(ymax), (x1 - x0), yOfE(glo) - yOfE(ymax));
            }
            ctx2d.restore();

            // gray forbidden regions
            ctx2d.save();
            ctx2d.globalAlpha = 0.28;
            ctx2d.fillStyle = "#6b7280";
            for (let i = 0; i < Math.floor(CFG.T / step); i++) {
                const tL = i * step, tR = (i + 1) * step, tM = 0.5 * (tL + tR);
                const ivs = grayIntervalsAt(tM);
                if (!ivs) continue;
                const x0 = xOfT(tL), x1 = xOfT(tR);
                for (const [lo, hi] of ivs) {
                    const y0 = yOfE(hi), y1 = yOfE(lo);
                    ctx2d.fillRect(x0, y0, (x1 - x0), (y1 - y0));
                }
            }
            ctx2d.restore();

            // green bound lines
            ctx2d.save();
            ctx2d.globalAlpha = 0.35;
            ctx2d.strokeStyle = "#cbd5e1";
            ctx2d.lineWidth = 2;

            ctx2d.beginPath();
            for (let i = 0; i <= Math.floor(CFG.T / CFG.dtPlot); i++) {
                const t = i * CFG.dtPlot;
                const [glo] = greenBounds(t);
                const x = xOfT(t), y = yOfE(glo);
                if (i === 0) ctx2d.moveTo(x, y); else ctx2d.lineTo(x, y);
            }
            ctx2d.stroke();

            ctx2d.beginPath();
            for (let i = 0; i <= Math.floor(CFG.T / CFG.dtPlot); i++) {
                const t = i * CFG.dtPlot;
                const [, ghi] = greenBounds(t);
                const x = xOfT(t), y = yOfE(ghi);
                if (i === 0) ctx2d.moveTo(x, y); else ctx2d.lineTo(x, y);
            }
            ctx2d.stroke();
            ctx2d.restore();

            // axes
            ctx2d.save();
            ctx2d.strokeStyle = "rgba(255,255,255,0.35)";
            ctx2d.lineWidth = 1;
            ctx2d.beginPath();
            ctx2d.moveTo(padL, padT);
            ctx2d.lineTo(padL, padT + innerH);
            ctx2d.lineTo(padL + innerW, padT + innerH);
            ctx2d.stroke();
            ctx2d.restore();

            // y ticks
            const kLabel = 5;
            ctx2d.save();
            ctx2d.font = "12px ui-sans-serif, system-ui";
            ctx2d.fillStyle = "rgba(255,255,255,0.75)";
            ctx2d.strokeStyle = "rgba(255,255,255,0.18)";
            for (let e = Math.ceil(ymin); e <= Math.floor(ymax); e++) {
                const y = yOfE(e);
                ctx2d.beginPath();
                ctx2d.moveTo(padL - 4, y);
                ctx2d.lineTo(padL, y);
                ctx2d.stroke();
                if (e % kLabel === 0) ctx2d.fillText(String(e), 12, y + 4);
            }
            ctx2d.restore();

            // labels
            ctx2d.save();
            ctx2d.fillStyle = "rgba(255,255,255,0.75)";
            ctx2d.font = "13px ui-sans-serif, system-ui";
            ctx2d.fillText("time (s)", padL + innerW / 2 - 26, H - 14);
            ctx2d.translate(16, padT + innerH / 2 + 40);
            ctx2d.rotate(-Math.PI / 2);
            ctx2d.fillText("evidence (#R - #L)", 0, 0);
            ctx2d.restore();

            // dashed zero line
            ctx2d.save();
            ctx2d.setLineDash([6, 6]);
            ctx2d.strokeStyle = "rgba(255,255,255,0.25)";
            ctx2d.lineWidth = 1;
            ctx2d.beginPath();
            ctx2d.moveTo(padL, yOfE(0));
            ctx2d.lineTo(padL + innerW, yOfE(0));
            ctx2d.stroke();
            ctx2d.restore();

            return { xOfT, yOfE };
        }

        function drawTrajectoryOnBase(base, trial, alpha = 0.15, lw = 1) {
            const { xOfT, yOfE } = base;
            const ts = trial.traj.ts;
            const E = trial.traj.E;
            const color = (trial.finalE > 0) ? "#ef4444" : (trial.finalE < 0) ? "#3b82f6" : "#22c55e";

            ctx2d.save();
            ctx2d.strokeStyle = color;
            ctx2d.globalAlpha = alpha;
            ctx2d.lineWidth = lw;
            ctx2d.beginPath();
            for (let k = 0; k < ts.length; k++) {
                const x = xOfT(ts[k]);
                const y = yOfE(E[k]);
                if (k === 0) ctx2d.moveTo(x, y);
                else ctx2d.lineTo(x, y);
            }
            ctx2d.stroke();
            ctx2d.restore();
        }

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        async function runSanityCheck(N = 1000) {
            // hide overlay + disable task buttons while running
            overlayEl.classList.add("hidden");
            setButtons({ start: false, lr: false, next: false, reveal: false });

            statusEl.textContent = `Sanity check: sampling ${N} trajectories…`;

            // draw base once
            const base = plotStateSpaceBaseFixedYRange();

            // sample + draw in batches so the UI doesn’t freeze
            const batch = 25;
            let ok = 0;
            let fail = 0;

            for (let i = 0; i < N; i++) {
                try {
                    const tr = sampleTrial(); // uses YOUR constrained sampler
                    drawTrajectoryOnBase(base, tr, 0.15, 1);
                    ok++;
                } catch (e) {
                    fail++;
                }

                if ((i + 1) % batch === 0) {
                    statusEl.textContent = `Sanity check: ${i + 1}/${N} done · ok=${ok} · fail=${fail}`;
                    await sleep(0); // yield to browser
                }
            }

            statusEl.textContent = `Sanity check complete · ok=${ok} · fail=${fail}`;
            setButtons({ start: true, lr: false, next: false, reveal: false });
        }


        function drawBlankPlot() {
            // blank plot area (nothing drawn)
            clearCanvas();
        }

        /** ---------------------------
         *  WebAudio (stereo click scheduling)
         *  --------------------------- */
        let audioCtx = null;
        function ensureAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        }

        function scheduleClick(ctx, when, panVal) {
            const osc = ctx.createOscillator();
            osc.type = "sine";
            osc.frequency.value = CFG.freqHz;

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.0, when);

            const dur = CFG.clickMs / 1000.0;
            gain.gain.linearRampToValueAtTime(CFG.amp, when + 0.0008);
            gain.gain.exponentialRampToValueAtTime(0.0001, when + dur);

            let pan;
            if (ctx.createStereoPanner) {
                pan = ctx.createStereoPanner();
                pan.pan.setValueAtTime(panVal, when);
            }

            osc.connect(gain);
            if (pan) gain.connect(pan).connect(ctx.destination);
            else gain.connect(ctx.destination);

            osc.start(when);
            osc.stop(when + dur + 0.02);
        }

        function playStereoClicks(tL, tR) {
            const ctx = ensureAudio();
            const start = ctx.currentTime + 0.08;
            for (const t of tL) scheduleClick(ctx, start + t, -1.0);
            for (const t of tR) scheduleClick(ctx, start + t, +1.0);

            const end = start + CFG.T + 0.05;
            return new Promise(resolve => {
                const ms = Math.max(0, (end - ctx.currentTime) * 1000);
                setTimeout(resolve, ms);
            });
        }

        /** ---------------------------
         *  UI wiring
         *  --------------------------- */
        const startBtn = document.getElementById("startBtn");
        const leftBtn = document.getElementById("leftBtn");
        const rightBtn = document.getElementById("rightBtn");
        const nextBtn = document.getElementById("nextBtn");
        const statusEl = document.getElementById("status");
        const sanityBtn = document.getElementById("sanityBtn");
        sanityBtn.addEventListener("click", () => runSanityCheck(1000));

        const overlayEl = document.getElementById("revealOverlay");
        const revealBtn = document.getElementById("revealBtn");

        let current = null;
        let awaitingResponse = false;
        let choice = null;
        let revealed = false;

        function setButtons({ start, lr, next, reveal }) {
            startBtn.disabled = !start;
            leftBtn.disabled = !lr;
            rightBtn.disabled = !lr;
            nextBtn.disabled = !next;
            revealBtn.disabled = !reveal;
        }

        function correctSide(finalE) {
            if (finalE > 0) return "right";
            if (finalE < 0) return "left";
            return "tie";
        }

        function verdictText(choice, correct) {
            if (correct === "tie") return `Tie (final evidence = 0).`;
            return (choice === correct) ? `✅ Correct (${correct.toUpperCase()})` : `❌ Wrong. Correct was ${correct.toUpperCase()}.`;
        }

        async function runTrial() {
            setButtons({ start: false, lr: false, next: false, reveal: false });
            statusEl.textContent = "Sampling a constrained trajectory…";

            try { current = sampleTrial(); }
            catch (e) {
                statusEl.textContent = "Failed to sample a valid trial (constraints may be too tight).";
                setButtons({ start: true, lr: false, next: false, reveal: false });
                return;
            }

            // Hide plot during decision phase
            revealed = false;
            overlayEl.classList.remove("hidden");
            drawBlankPlot();

            // Decision phase: play audio only
            awaitingResponse = true;
            choice = null;
            statusEl.textContent = "Listen…";

            await playStereoClicks(current.tL, current.tR);

            statusEl.textContent = "Choose: Left or Right.";
            setButtons({ start: false, lr: true, next: false, reveal: false });
        }

        function finishDecision(userChoice) {
            if (!awaitingResponse) return;
            awaitingResponse = false;
            choice = userChoice;

            const corr = correctSide(current.finalE);
            statusEl.textContent = verdictText(choice, corr) + "  (Click Reveal to see the trajectory.)";

            // enable reveal button; keep overlay up
            setButtons({ start: false, lr: false, next: false, reveal: true });
        }

        async function doReveal() {
            if (!current || revealed) return;
            revealed = true;

            // hide overlay, then replay audio AND draw live trajectory
            overlayEl.classList.add("hidden");

            // animate draw during playback
            let t0 = performance.now();
            let running = true;
            const animate = () => {
                if (!running) return;
                const elapsed = (performance.now() - t0) / 1000;
                const frac = Math.min(1, elapsed / CFG.T);
                drawTrajectory(current, frac);
                if (frac < 1) requestAnimationFrame(animate);
            };
            requestAnimationFrame(animate);

            await playStereoClicks(current.tL, current.tR);
            running = false;
            drawTrajectory(current, 1.0);

            // allow next
            setButtons({ start: false, lr: false, next: true, reveal: false });
            statusEl.textContent += "  (Reveal complete.)";
        }

        function resetToStart() {
            current = null;
            awaitingResponse = false;
            choice = null;
            revealed = false;

            overlayEl.classList.remove("hidden");
            revealBtn.disabled = true;
            drawBlankPlot();

            statusEl.textContent = "Press Start.";
            setButtons({ start: true, lr: false, next: false, reveal: false });
        }

        startBtn.addEventListener("click", () => runTrial());
        leftBtn.addEventListener("click", () => finishDecision("left"));
        rightBtn.addEventListener("click", () => finishDecision("right"));
        revealBtn.addEventListener("click", () => doReveal());
        nextBtn.addEventListener("click", () => resetToStart());

        // init
        resetToStart();
    </script>
</body>

</html>