<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PredClick</title>
    <link rel="stylesheet" href="./css/style.css" />
</head>

<body>
    <div class="wrap">
        <div class="card">
            <h1>PredClick</h1>
            <p>Listen to binaural clicks (left stream in left ear, right stream in right ear). Decide which side had
                more clicks.</p>

            <div class="row">
                <button id="startBtn" class="primary">Start</button>
                <button id="leftBtn" disabled>Left</button>
                <button id="rightBtn" disabled>Right</button>
                <button id="nextBtn" disabled>Next trial</button>
                <button id="sanityBtn">Sanity check</button>
            </div>

            <div class="status" id="status">Press Start.</div>
            <p class="small">Tip: use headphones. (Audio requires a button press.)</p>

            <div class="plotWrap">
                <canvas id="cv" width="920" height="520"></canvas>
                <div id="revealOverlay" class="overlay">
                    <button id="revealBtn" disabled>Reveal</button>
                </div>
            </div>
        </div>
    </div>
    <!-- <script type="module" src="./js/main.js"></script> -->
    <script type="module">
        import { CFG } from "./js/config.js";
        import { greenBounds, grayIntervalsAt, allowed } from "./js/bounds.js";
        import {
            sampleTrial,
            evidenceTrajectory,
            generateClicksWithConstraintsBinwise,
            checkConstraintsOnGrid
        } from "./js/sampler.js";
        import { initPlotting } from "./js/plotting.js";

        /** ---------------------------
         *  Canvas plotting
         *  --------------------------- */
        const cv = document.getElementById("cv");
        const plot = initPlotting(cv);

        // optional for debugging only:
        window.CFG = CFG;
        window.greenBounds = greenBounds;
        window.grayIntervalsAt = grayIntervalsAt;
        window.allowed = allowed;
        window.sampleTrial = sampleTrial;
        window.evidenceTrajectory = evidenceTrajectory;
        window.generateClicksWithConstraintsBinwise = generateClicksWithConstraintsBinwise;
        window.checkConstraintsOnGrid = checkConstraintsOnGrid;

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        async function runSanityCheck(N = 1000) {
            // hide overlay + disable task buttons while running
            overlayEl.classList.add("hidden");
            setButtons({ start: false, lr: false, next: false, reveal: false });

            statusEl.textContent = `Sanity check: sampling ${N} trajectories…`;

            // draw base once
            const base = plot.plotStateSpaceBaseFixedYRange();

            // sample + draw in batches so the UI doesn’t freeze
            const batch = 25;
            let ok = 0;
            let fail = 0;

            for (let i = 0; i < N; i++) {
                try {
                    const tr = sampleTrial(); // uses YOUR constrained sampler
                    plot.drawTrajectoryOnBase(base, tr, 0.15, 1);
                    ok++;
                } catch (e) {
                    fail++;
                }

                if ((i + 1) % batch === 0) {
                    statusEl.textContent = `Sanity check: ${i + 1}/${N} done · ok=${ok} · fail=${fail}`;
                    await sleep(0); // yield to browser
                }
            }

            statusEl.textContent = `Sanity check complete · ok=${ok} · fail=${fail}`;
            setButtons({ start: true, lr: false, next: false, reveal: false });
        }

        /** ---------------------------
         *  WebAudio (stereo click scheduling)
         *  --------------------------- */
        let audioCtx = null;
        function ensureAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        }

        function scheduleClick(ctx, when, panVal) {
            const osc = ctx.createOscillator();
            osc.type = "sine";
            osc.frequency.value = CFG.freqHz;

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.0, when);

            const dur = CFG.clickMs / 1000.0;
            gain.gain.linearRampToValueAtTime(CFG.amp, when + 0.0008);
            gain.gain.exponentialRampToValueAtTime(0.0001, when + dur);

            let pan;
            if (ctx.createStereoPanner) {
                pan = ctx.createStereoPanner();
                pan.pan.setValueAtTime(panVal, when);
            }

            osc.connect(gain);
            if (pan) gain.connect(pan).connect(ctx.destination);
            else gain.connect(ctx.destination);

            osc.start(when);
            osc.stop(when + dur + 0.02);
        }

        function playStereoClicks(tL, tR) {
            const ctx = ensureAudio();
            const start = ctx.currentTime + 0.08;
            for (const t of tL) scheduleClick(ctx, start + t, -1.0);
            for (const t of tR) scheduleClick(ctx, start + t, +1.0);

            const end = start + CFG.T + 0.05;
            return new Promise(resolve => {
                const ms = Math.max(0, (end - ctx.currentTime) * 1000);
                setTimeout(resolve, ms);
            });
        }

        /** ---------------------------
         *  UI wiring
         *  --------------------------- */
        const startBtn = document.getElementById("startBtn");
        const leftBtn = document.getElementById("leftBtn");
        const rightBtn = document.getElementById("rightBtn");
        const nextBtn = document.getElementById("nextBtn");
        const statusEl = document.getElementById("status");
        const sanityBtn = document.getElementById("sanityBtn");
        sanityBtn.addEventListener("click", () => runSanityCheck(1000));

        const overlayEl = document.getElementById("revealOverlay");
        const revealBtn = document.getElementById("revealBtn");

        let current = null;
        let awaitingResponse = false;
        let choice = null;
        let revealed = false;

        function setButtons({ start, lr, next, reveal }) {
            startBtn.disabled = !start;
            leftBtn.disabled = !lr;
            rightBtn.disabled = !lr;
            nextBtn.disabled = !next;
            revealBtn.disabled = !reveal;
        }

        function correctSide(finalE) {
            if (finalE > 0) return "right";
            if (finalE < 0) return "left";
            return "tie";
        }

        function verdictText(choice, correct) {
            if (correct === "tie") return `Tie (final evidence = 0).`;
            return (choice === correct) ? `✅ Correct (${correct.toUpperCase()})` : `❌ Wrong. Correct was ${correct.toUpperCase()}.`;
        }

        async function runTrial() {
            setButtons({ start: false, lr: false, next: false, reveal: false });
            statusEl.textContent = "Sampling a constrained trajectory…";

            try { current = sampleTrial(); }
            catch (e) {
                statusEl.textContent = "Failed to sample a valid trial (constraints may be too tight).";
                setButtons({ start: true, lr: false, next: false, reveal: false });
                return;
            }

            // Hide plot during decision phase
            revealed = false;
            overlayEl.classList.remove("hidden");
            plot.drawBlankPlot();

            // Decision phase: play audio only
            awaitingResponse = true;
            choice = null;
            statusEl.textContent = "Listen…";

            await playStereoClicks(current.tL, current.tR);

            statusEl.textContent = "Choose: Left or Right.";
            setButtons({ start: false, lr: true, next: false, reveal: false });
        }

        function finishDecision(userChoice) {
            if (!awaitingResponse) return;
            awaitingResponse = false;
            choice = userChoice;

            const corr = correctSide(current.finalE);
            statusEl.textContent = verdictText(choice, corr) + "  (Click Reveal to see the trajectory.)";

            // enable reveal button; keep overlay up
            setButtons({ start: false, lr: false, next: false, reveal: true });
        }

        async function doReveal() {
            if (!current || revealed) return;
            revealed = true;

            // hide overlay, then replay audio AND draw live trajectory
            overlayEl.classList.add("hidden");

            // animate draw during playback
            let t0 = performance.now();
            let running = true;
            const animate = () => {
                if (!running) return;
                const elapsed = (performance.now() - t0) / 1000;
                const frac = Math.min(1, elapsed / CFG.T);
                plot.drawTrajectory(current, frac);
                if (frac < 1) requestAnimationFrame(animate);
            };
            requestAnimationFrame(animate);

            await playStereoClicks(current.tL, current.tR);
            running = false;
            plot.drawTrajectory(current, 1.0);

            // allow next
            setButtons({ start: false, lr: false, next: true, reveal: false });
            statusEl.textContent += "  (Reveal complete.)";
        }

        function resetToStart() {
            current = null;
            awaitingResponse = false;
            choice = null;
            revealed = false;

            overlayEl.classList.remove("hidden");
            revealBtn.disabled = true;
            plot.drawBlankPlot();

            statusEl.textContent = "Press Start.";
            setButtons({ start: true, lr: false, next: false, reveal: false });
        }

        startBtn.addEventListener("click", () => runTrial());
        leftBtn.addEventListener("click", () => finishDecision("left"));
        rightBtn.addEventListener("click", () => finishDecision("right"));
        revealBtn.addEventListener("click", () => doReveal());
        nextBtn.addEventListener("click", () => resetToStart());

        // init
        resetToStart();
    </script>
</body>

</html>